/// User data for field of view cells.
pub trait State: PartialEq + Clone {
    type Vector: Into<[i32; 2]>;

    /// Construct a new FovValue for a position based on the previous one
    /// along the line of sight.
    ///
    /// Return `None` if line of sight does not continue past this point.
    fn advance(&self, offset: Self::Vector) -> Option<Self>;
}

/// Point in FOV arc polar coordinates for the desired geometry.
pub trait Geometry: Sized + Clone {
    type Vector;

    /// Create the beginning and end points for radius 1 unit circle.
    ///
    /// These are the initial cells checked by the FOV algorithm.
    fn unit_circle_endpoints() -> (Self, Self);

    /// Return whether this point is earlier in the circle than the other.
    fn is_below(&self, other: &Self) -> bool;

    /// Return the vector offset for this point.
    fn to_v2(&self) -> Self::Vector;

    /// Return the point corresponding to this one on the next circle with +1
    /// radius.
    fn expand(&self) -> Self;

    /// Step forward on the current radius.
    fn advance(&mut self);
}

/// Field of view iterator.
pub struct Fov<P: Geometry, T> {
    stack: Vec<FovArc<P, T>>,
    /// Extra values generated by special cases.
    side_channel: Vec<(P::Vector, T)>,
}

impl<V, P, T> Fov<P, T>
where
    V: From<[i32; 2]>,
    P: Geometry<Vector = V>,
    T: State<Vector = V>,
{
    /// Create a new field of view iterator with a seed userdata for the
    /// origin position.
    pub fn new(init: T) -> Fov<P, T> {
        // We could run f for (0, 0) here, but the traditional way for the FOV
        // to work is to only consider your surroundings, not the origin site
        // itself.
        Fov {
            stack: vec![FovArc::new(init.clone())],
            // The FOV algorithm will not generate the origin point, so we use
            // the side channel to explicitly add it in the beginning.
            side_channel: vec![(V::from([0, 0]), init)],
        }
    }
}

impl<V, P, T> Iterator for Fov<P, T>
where
    V: From<[i32; 2]>,
    P: Geometry<Vector = V>,
    T: State<Vector = V>,
{
    type Item = (V, T);
    fn next(&mut self) -> Option<(V, T)> {
        // Empty the side channel before proceeding to the algorithm proper.
        if let Some(ret) = self.side_channel.pop() {
            return Some(ret);
        }

        // Start processing the next arc in the stack.
        if let Some(current) = self.stack.pop() {
            if current.arc_has_split(&mut self.stack) {
                return self.next();
            }

            debug_assert!(
                current.group_value
                    == current.prev_value.advance(current.pt.to_v2())
            );

            let pos = current.pt.to_v2();
            let ret = current.group_value.clone();

            current.advance(&mut self.stack);

            if let Some(ret) = ret {
                Some((pos, ret))
            } else {
                self.next()
            }
        } else {
            None
        }
    }
}

struct FovArc<P, T> {
    /// Start point of current arc.
    begin: P,
    /// Point currently being processed.
    pt: P,
    /// End point of current arc.
    end: P,
    /// The user value from previous iteration.
    prev_value: T,
    /// The user value for this group.
    group_value: Option<T>,
}

impl<V, P, T> FovArc<P, T>
where
    P: Geometry<Vector = V>,
    T: State<Vector = V>,
{
    pub fn new(init: T) -> FovArc<P, T> {
        let (begin, end) = P::unit_circle_endpoints();
        Self::expand(begin, end, init)
    }

    fn expand(begin: P, end: P, prev_value: T) -> FovArc<P, T> {
        let group_value = prev_value.advance(begin.to_v2());
        FovArc {
            begin: begin.clone(),
            pt: begin,
            end,
            prev_value,
            group_value,
        }
    }

    /// Consume the given arc and add its descendant, if any, to the stack.
    pub fn advance(mut self, stack: &mut Vec<FovArc<P, T>>) {
        self.pt.advance();
        if self.pt.is_below(&self.end) {
            stack.push(self);
        } else if let Some(group_value) = self.group_value {
            stack.push(FovArc::expand(
                self.begin.expand(),
                self.end.expand(),
                group_value,
            ));
        }
    }

    /// If the arc has advanced into a different value group, split it into
    /// the given stack.
    ///
    /// Return true if arc was split, false otherwise.
    pub fn arc_has_split(&self, stack: &mut Vec<FovArc<P, T>>) -> bool {
        let next_value = self.prev_value.advance(self.pt.to_v2());
        if next_value != self.group_value {
            // Using the literal instead of the constructor to avoid
            // recomputing next_value.
            stack.push(FovArc {
                begin: self.pt.clone(),
                pt: self.pt.clone(),
                end: self.end.clone(),
                prev_value: self.prev_value.clone(),
                group_value: next_value,
            });

            // Extend current arc if it has a group value.
            if let Some(ref group_value) = self.group_value {
                stack.push(FovArc::expand(
                    self.begin.expand(),
                    self.pt.expand(),
                    group_value.clone(),
                ));
            }

            true
        } else {
            false
        }
    }
}
