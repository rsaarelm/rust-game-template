use std::process::Command;

fn main() -> anyhow::Result<()> {
    write_version()?;
    write_data()
}

/// Derive version string from git status.
fn write_version() -> anyhow::Result<()> {
    println!("cargo:rerun-if-changed=src/version.rs");
    std::fs::write(
        "src/version.rs",
        format!(
            "// THIS FILE IS GENERATED BY build.rs, DO NOT EDIT OR PLACE IN VERSION CONTROL.\npub const VERSION: &str = \"{}\";\n",
            get_git_hash()?
        ),
    )?;
    Ok(())
}

/// Bake data directory contents into a single snap-packaged IDM file.
fn write_data() -> anyhow::Result<()> {
    // Make sure build.rs gets rerun if the output file disappears.
    println!("cargo:rerun-if-changed=data");
    println!("cargo:rerun-if-changed=target/data.idm.sz");
    let data = util::dir_to_idm("data").unwrap().to_string();
    // Save the uncompressed version for debugging.
    std::fs::write("target/data.idm", data.as_bytes()).unwrap();
    // Save compressed data for embedding in game binary.
    let sz = snap::raw::Encoder::new()
        .compress_vec(data.as_bytes())
        .unwrap();
    std::fs::write("target/data.idm.sz", sz).unwrap();

    Ok(())
}

/// If git commit message starts with "Release ", assume this is a release
/// commit and use Cargo version, otherwise construct a version string from
/// the hash of git HEAD.
fn get_git_hash() -> anyhow::Result<String> {
    let version = env!("CARGO_PKG_VERSION");

    let hash = String::from_utf8(
        Command::new("git")
            .args(["rev-parse", "--short", "HEAD"])
            .output()?
            .stdout,
    )?;

    let message = String::from_utf8(
        Command::new("git")
            .args(["show", "-s", "--format=%s"])
            .output()?
            .stdout,
    )?;

    if message.starts_with("Release ") {
        Ok(version.into())
    } else {
        Ok(format!("{version}-{}", hash.trim()))
    }
}
