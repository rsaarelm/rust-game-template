use glam::IVec2;
use num_traits::{One, Zero};

use crate::{s4, HashSet};
use std::{collections::VecDeque, hash::Hash, ops::Add};

/// Generate a shortest paths map on a grid according to a neighbors function.
pub fn dijkstra_map<'a, T, I>(
    mut neighbors: impl FnMut(&T) -> I + 'a,
    starts: impl IntoIterator<Item = T>,
) -> impl Iterator<Item = (T, usize)> + 'a
where
    T: Clone + Eq + Hash + 'a,
    I: IntoIterator<Item = T>,
{
    let mut edge: VecDeque<(T, usize)> =
        starts.into_iter().map(|s| (s, 0)).collect();
    let mut seen = HashSet::default();

    std::iter::from_fn(move || {
        // Candidates are in a queue and consumed first-in, first-out. This
        // should guarantee that the first time a node is popped from the queue
        // it shows the shortest path length from start to that node.

        while let Some((node, len)) = edge.pop_front() {
            if !seen.contains(&node) {
                seen.insert(node.clone());
                for n in neighbors(&node) {
                    edge.push_back((n, len + 1));
                }
                return Some((node, len));
            }
        }
        None
    })
}

/// Path towards `end` by minimizing `heuristic(a, end)` for path points `a`
/// generated by `neighbors` and starting from `start`.
///
/// Returns reversed path without the start position if successful. If the
/// heuristic always returns a number equal or smaller to the steps needed to
/// reach the goal, will return an optimal path.
pub fn astar_path<T, I, N>(
    start: &T,
    end: &T,
    neighbors: impl Fn(&T) -> I,
    heuristic: impl Fn(&T, &T) -> N,
) -> Option<Vec<T>>
where
    T: Clone + Eq + Hash,
    N: Zero + One + Ord + Copy,
    I: IntoIterator<Item = T>,
{
    pathfinding::prelude::astar(
        start,
        |a| neighbors(a).into_iter().map(|c| (c, N::one())),
        |a| heuristic(a, end),
        |a| a == end,
    )
    .map(|(mut path, _)| {
        path.reverse();
        path.pop();
        path
    })
}

/// Create an iterator that flood fills in taxicab metric from origin.
///
/// Cells for which is_valid returns false are not returned. Cells are
/// returned with monotonically increasing distance of shortest path along
/// valid cells from origin.
pub fn flood_fill_4<'a, T>(
    is_valid: &'a impl Fn(&T) -> bool,
    starts: impl IntoIterator<Item = T>,
) -> impl Iterator<Item = (T, usize)> + 'a
where
    T: Clone + Eq + Hash + Add<IVec2, Output = T> + 'a,
{
    crate::dijkstra_map(
        move |n| {
            let mut ret = Vec::new();
            for d in s4::DIR {
                let n = n.clone() + d;
                if is_valid(&n) {
                    ret.push(n);
                }
            }
            ret
        },
        starts,
    )
}

/// Combinator for limiting flood fill to a given distance.
pub fn within_range<T>(n: usize) -> impl FnMut(&(T, usize)) -> bool {
    move |&(_, k)| k < n
}
