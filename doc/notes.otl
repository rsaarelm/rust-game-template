Misc notes about non-obvious bits
Should eventually be sorted into a more coherent document
For now I'm just writing these down as I run into them

Async runner functions and display frames
	Runner functions like run::explore, run::aim should do a draw().await early on to start a new frame
	If they are triggered by an earlier runner and don't switch frame, they will be seeing the same keypress the previous frame saw
	This causes the keypress to be used for two different actions

Upstairs go north, downstairs go south on maps
	Because north = up, south = down, visually

ECS components for entities should have default values that make sense for "not defined for this entity"
	Eg. if it's just a number, zero should be same as "not defined"
	Wrap the type in Option if a missing value isn't clearly expressed otherwise
	Enum-type components have a `None` value in the main enum just to avoid the extra layering of an Option around it
		This might be bad design and need to be changed

The widget idiom
	Widgets are basically fancier IMGUI buttons, up to full game map view
	The idea is to have complex UI logic inside them, but never do mutable actions directly when the widget is being rendered
	Instead, the widget will return a typed value describing actions
		This can be an enum sum of multiple different actions, in case of things like map view
	The caller can then choose to perform the changes indicated by the return value or ignore it
	This lets us have an active or an inactive map widget on screen, depending on what is done with the return value
	Most of the complexity involved with the widget display is capsulated inside the draw command

Gamestate reproducibility
	The game must end up in the exact same state in every run on every platform given the same initial RNG seed and sequence of player inputs
	Ways to break state reproducibility
		Rely on the iteration order of a Hash based container at any point
			Avoid HashMap and HashSet in map generation or determinining the order of acting entities
			Use BTreeMap/Set or IndexMap/Set instead
		Mixing user interface actions or wall clock time with game mechanics
			Have the runtime use its own RNG and don't have UI affect it by any other means than pushing command inputs to runtime
		Different behavior on different platforms
			Is the RNG same on 32-bit and 64-bit platforms?
			Is the RNG same on big-endian and little-endian platforms?
		Rely on a hash function that's not stable over platforms
			FxHash hashing seems to vary between 32 and 64 bits
			Use a specific named hash implementation like twox_hash
	The util crate should provide a RNG that works the same on all platforms
		The RNG algorithm needs to be known
		Just going with "whatever the standard library provides" will break reproducibility if the standard library changes their algorithm

Game loop order issues
	Call screen render async function early in UI mode functions
	This will refresh navni's currently cached keypress
	You do not want to accidentally reuse the keypress value from the previous state function that sent you to this one by staying on the same frame for two separate logic blocks

IDM things
	String blocks sometimes use NBSP as left padding for things saved in IDM files, since IDM does not consider NBSP as indentation
	When writing code that generates this, always escape NBSP chars as \u{00a0} instead of emitting a literal NBSP character in the code
	People reading the code can't tell the difference between a literal NBSP and ASCII space on sight, so the code can be very confusing if they don't know about the NBSP trick
